<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ch-16</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="chapter-15-complex-numbers">Chapter 15: Complex Numbers</h1>
<p><a href="index.html">Return to all notes</a></p>
<p>Recall that the imaginary unit <span class="math inline">\(i\)</span> is defined as the number such that <span class="math inline">\(i^{2}=-1\)</span>. In Maple, this is a built-the constant <span class="math inline">\(I\)</span>. Just for kicks, try it:</p>
<pre><code>I^2</code></pre>
<p>and you get <span class="math inline">\(-1\)</span>.</p>
<h2 id="the-complex-plane">The Complex Plane</h2>
<p>The complex plane is just like the <span class="math inline">\(xy\)</span>-plane in which the horizontal axis is the real axis and the vertical one is the imaginary axis.<br />
We can plot any point <span class="math inline">\(x\_1+i y\_1\)</span> as the point <span class="math inline">\((x\_1,y\_1)\)</span> on the standard <span class="math inline">\(xy\)</span>-plane.</p>
<p>(add a plot)</p>
<h2 id="the-real-an-imaginary-parts-of-a-complex-number">The real an imaginary parts of a complex number</h2>
<p>If <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are real numbers and we define <span class="math inline">\(z=x+iy\)</span>, then there are functions that return the real and imaginary parts of <span class="math inline">\(z\)</span>. Mathematically, we use <span class="math inline">\(\Re(z)\)</span> and <span class="math inline">\(\Im(z)\)</span> to represent these and they are defined as</p>
<p><span class="math display">\[\Re(z)=x \qquad \Im(z)=y\]</span></p>
<p>and note that the imaginary part of a complex number is a real number.</p>
<p>In Maple, we use the commands <code>Re</code> and <code>Im</code>. If we define</p>
<pre><code>z:=3+4I</code></pre>
<p>Then <code>Re(z)</code> returns 3 and <code>Im(z)</code> returns 4.</p>
<h2 id="the-polar-form-of-a-complex-number">The Polar Form of a complex number</h2>
<p>Another important form of a complex number is called the <em>polar form</em>. If we find <span class="math inline">\(r\)</span>, the distance from the origin to the point <span class="math inline">\((x,y)\)</span> and <span class="math inline">\(\theta\)</span>, the counterclockwise angle between the positive <span class="math inline">\(x\)</span> axis and the line segment as shown</p>
<figure>
<img src="images/ch15/plot01.png" alt="Polar form of z" /><figcaption aria-hidden="true">Polar form of <span class="math inline">\(z\)</span></figcaption>
</figure>
<p>The distance <span class="math inline">\(r\)</span> is defined as <span class="math inline">\(r=\sqrt{x^{2}+y^{2}}\)</span> and <span class="math inline">\(\theta = \tan^{-1} (y/x)\)</span> (and it might need to be shifted depending on the quadrant of the point.)</p>
<p>In addition, the distance <span class="math inline">\(r\)</span> is often denoted as <span class="math inline">\(|z|\)</span>, where the standard absolute value symbol is used.</p>
<p>Maple uses the absolute value symbol for the distance and the <code>argument</code> command for the angle. For example, if</p>
<pre><code>z:=3+4*I</code></pre>
<p>then <code>|z|</code> returns 5 and <code>argument(z)</code> returns <span class="math inline">\(\arctan(4/3)\)</span>. The argument of <span class="math inline">\(2+2I\)</span> is <span class="math inline">\(\pi/4\)</span>.</p>
<p>(complex exponential form)</p>
<h2 id="complex-conjugate">Complex Conjugate</h2>
<p>If <span class="math inline">\(z=x+iy\)</span>, then the complex conjugate of <span class="math inline">\(z\)</span>, denoted <span class="math inline">\(\overline{z}\)</span> is <span class="math inline">\(x-iy\)</span>. In short, it switches the sign of the imaginary term.</p>
<p>In Maple, the command <code>conjugate</code> will return the complex conjugate.</p>
<pre><code>conjugate(z)</code></pre>
<p>returns <span class="math inline">\(3-4i\)</span>.</p>
<p>You can enter the conjugate by typing the first of <code>conjugate</code>, hitting ESC and selecting <span class="math inline">\(\overline{x}\)</span>.</p>
<p>Note that it is common that a complex number is mutiplied by its conjugate, so <span class="math display">\[\begin{array}{rl} z \overline{z} &amp; = (x+iy)(x-iy)  \\
&amp; = x^{2} +ixy-ixy-i^{2}y^{2} = x^{2}+y^{2}\end{array}\]</span></p>
<p>which is <span class="math inline">\(|z|^2\)</span>.</p>
<h3 id="complex-exponential-form">Complex Exponential form</h3>
<p>Using the distance and angle of a complex number, we can write a number <span class="math inline">\(z\)</span> as <span class="math display">\[ z = r e^{i \theta}\]</span> because <span class="math display">\[e^{i \theta} = \cos \theta + i \sin \theta\]</span> so, <span class="math display">\[
\begin{array}{rl}
z &amp; = r (\cos \theta + i \sin \theta) \newline
&amp; = r \cos \theta + i r \sin \theta \newline
&amp; = x + i y
\end{array} \]</span></p>
<h2 id="arithmetic-with-complex-numbers.">Arithmetic with complex numbers.</h2>
<p>Maple can handle standard arithmetic operations with complex nubmers. Just to recall if <span class="math display">\[z_1=x\_1+i y\_1 \qquad z_2 = x\_2 + i y\_2\]</span></p>
<p>then <span class="math display">\[\begin{array}{rl}
z\_1 + z\_2 &amp; = (x\_1+x\_2) + i(y\_1+y\_2)\newline
z\_1 - z\_2 &amp; = (x\_1-x\_2) + i(y\_1-y\_2) \newline
z\_1 z\_2 &amp; = (x\_1+iy\_1)(x\_2+iy\_2) \newline
&amp; = (x\_1x\_2+iy\_1x\_2+ix\_1y\_2+i^\{2}y\_1y\_2)\newline
&amp; = (x\_1x\_2-y\_1y\_2)+i(x\_1y\_2+x\_2y\_1)
\end{array}\]</span></p>
<p>Also, if we have <span class="math inline">\(1/z_1\)</span>, then we can write this as <span class="math display">\[\begin{array}{rl}
\dfrac{1}{z\_1} &amp; = \dfrac{1}{x\_1+iy\_1} \end{array}\]</span> mulitply top and bottom by <span class="math inline">\(\overline{z_1}\)</span> <span class="math display">\[\begin{array}{rl}
\dfrac{1}{z_1} = \dfrac{1}{z_1}\dfrac{\overline{z_1}}{\overline{z_1}} &amp; = \dfrac{1}{x\_1+iy\_1} \dfrac{x\_1-iy\_1}{x\_1-iy\_1} \\
&amp;= \dfrac{x\_1-iy\_1}{x\_1^{2}+y\_1^{2}}
\end{array}\]</span> and in a similar manner: <span class="math display">\[\begin{array}{rl}
\dfrac{z_1}{z_2} &amp; = \dfrac{x\_1+iy\_1}{x\_2+iy\_2} \\
&amp; = \dfrac{x\_1+iy\_1}{x\_2+iy\_2} \dfrac{x\_2-iy\_2}{x\_2-iy\_2} \\
&amp; = \dfrac{x\_1x\_2+y\_1y\_2+i(y\_1x\_2-y\_2x\_1)}{x\_2^{2}+y\_2^{2}}
\end{array}\]</span></p>
<p>An integer power of a number is found by successive multiplications. For example, <span class="math display">\[
z^{2} = (x+iy)(x+iy)=x^{2}-y^{2}+2xy i
\]</span></p>
<p>Maple can do all of these operations naturally. For example, if</p>
<pre><code>z1:=3+4i
z2:=2-2i</code></pre>
<p>Then <code>z1+z2</code> returns <span class="math inline">\(5+2I\)</span>, <code>z1-x2</code> returns <span class="math inline">\(1+6I\)</span>, <code>z1*z2</code> returns <span class="math inline">\(14+2I\)</span> and <code>z1/z2</code> returns <span class="math display">\[-\frac{1}{4}+\frac{7}{4}I\]</span></p>
<p><code>z1^2</code> returns <span class="math inline">\(-7+24I\)</span>.</p>
<h3 id="multiplication-and-powers-of-complex-numbers-in-polar-form">Multiplication and Powers of Complex Numbers in Polar Form</h3>
<p>If we write <span class="math display">\[ z\_1 = r\_1 e^{i \theta\_1} \qquad
z\_2 = r\_2 e^{i \theta\_2}\]</span></p>
<p>then <span class="math display">\[
\begin{array}{rl}
z\_1 z\_2 &amp; = r\_1 e^{i \theta\_1} r\_2 e^{i \theta\_2} \newline
&amp; = r_1 r_2 e^{i(\theta\_1+\theta\_2)}
\end{array}
\]</span> or in other words, the product of two complex numbers is found by multiplying the distances and the angle is the sum.</p>
<p>We can find the product of <span class="math inline">\(z_1 = 1+i\)</span> and <span class="math inline">\(z\_2 = 2i\)</span> using the above method, or write <span class="math display">\[
z\_1 = \sqrt{2} e^{i\pi/4}
\qquad z\_2 = 2 e^{i\pi/2}
\]</span></p>
<p>and <span class="math display">\[
\begin{array}{rl}
z\_1z\_2 &amp; = r_1 r_2 e^{i(\theta\_1+\theta\_2)} \newline
&amp; = 2\sqrt{2} e^{i 3\pi/4}
\end{array}
\]</span></p>
<p>A plot of this is: <img src="images/ch15/plot03.png" alt="Plot of the product of two complex numbers" /></p>
<p>The two numbers on the right side of the plot are multiplied. The sum of the angle is <span class="math inline">\(3\pi/4\)</span>, which is the angle of the resultant. The distance of the resultant is the product of the two <span class="math inline">\(\sqrt{2}\)</span> and <span class="math inline">\(2\)</span>.</p>
<p>The powers of a complex number also have an interesting geometry. If <span class="math inline">\(z=1+i=\sqrt{2}e^{i\pi/4}\)</span>, then powers of <span class="math inline">\(z\)</span> can be written as <span class="math display">\[z^{n} = (\sqrt{2})^{n} e^{i n \pi/4}\]</span></p>
<p>This can be interpreted as raising the distance to the <span class="math inline">\(n\)</span>th power and rotating the angle <span class="math inline">\(n\)</span> times around. For example, the plot about actually shows the number and its 2nd and 3rd power.</p>
<p>If the power is a fraction, we can interpret the same way. For example, the square root of <span class="math inline">\(z\)</span> can be written: <span class="math display">\[
\sqrt{z}  = \sqrt{r e^{i\theta}} = \sqrt{r} e^{i\theta/2}
\]</span></p>
<p>What this means is that to find the square root of a complex number, you take the square root of the distance and then return the number with angle half of the input.</p>
<h4 id="example">Example</h4>
<p>Find the square root of <span class="math inline">\(z=-1+\sqrt{3}i\)</span>. Note that <span class="math inline">\(|z|=\sqrt{1^{2}+(-\sqrt{3})^{2}}= \sqrt{4}=2\)</span> and that the angle (argument) is <span class="math inline">\(2\pi/3\)</span>. The resultant would have distance <span class="math inline">\(\sqrt{2}\)</span> and the angle would be <span class="math inline">\(\pi/3\)</span> so <span class="math display">\[
\sqrt{z} = \sqrt{2}e^{i\pi/3}\]</span></p>
<h2 id="newtons-method-in-the-complex-plane">Newton’s Method in the Complex Plane</h2>
<p>In <a href="ch13.html">Chapter 13</a>, we met Newton’s method. It works with complex numbers as well. For example, consider the function <span class="math display">\[ f(x)=x^{2}+4\]</span> which does not have a root in the reals. If we use</p>
<pre><code>NewtonsMethod(x^2+4, x = 1)</code></pre>
<p>in Maple with this function, we get: <code>1.683061201</code> which is clearly not right. If instead we plot it: <code>NewtonsMethod(x^2+4, x = 1,output=plot)</code></p>
<p>we get the plot: <img src="images/ch15/plot02.png" alt="Plot of Newton’s method on f(x)=x^{2}+4" /></p>
<p>And if you follow the plot starting at <span class="math inline">\(x=1\)</span>, it ends up at <span class="math inline">\(x=1.68\)</span> and will never converge.</p>
<p>If we return to an alternative way of writing Newton’s method for this, <span class="math display">\[ x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>and in Maple, we can do</p>
<pre><code>x(n):=x(n-1)-(x(n-1)^2+4)/(2x(n-1))
x(1):=1.0</code></pre>
<p>and then</p>
<pre><code>seq(x(n),n=0..5)</code></pre>
<p>we get:</p>
<pre><code>1.0, -1.500000000, .583333333, -3.136904764, -.930881225, 1.683061201</code></pre>
<p>which is the same result as above. If instead, we start with a complex number,</p>
<pre><code>x(0)=1.0I</code></pre>
<p>and then</p>
<pre><code>seq(x(n),n=0..5)</code></pre>
<p>results in</p>
<pre><code>1.0I, 2.500000000I, 2.050000000I, 2.000609756I, 2.000000093I, 2.000000000I</code></pre>
<p>We can find the other root <span class="math inline">\(-2i\)</span> if we let <code>x(0):=-1.0I</code></p>
<p>and note that <span class="math inline">\(2i\)</span> is the root of the function.</p>
<h3 id="a-procedure-to-do-newtons-method">A Procedure to do Newton’s method</h3>
<p>Before continuing on, we will write a procedure to do Newton’s method.</p>
<pre><code>newton := proc (f::procedure, x0::complex, { eps::numeric := 10^(-4), maxsteps::posint := 100 })
  local x1, x2, n;
  x1 := x0:
  for n to maxsteps do
    x2 := x1-f(x1)/f&#39;(x1):
    if abs(x2-x1) &lt; eps then
      return x2:
    end if:
    x1 := x2:
  end do;
  error &quot;The maximum number of steps %1 reached without convergence&quot;, maxsteps :
end proc:</code></pre>
<p>If we do</p>
<pre><code>newton(x-&gt;x^2-2,1.0)</code></pre>
<p>we get <code>1.414213562</code> and if we do <code>newton(x-&gt;x^2+4,1.0)</code> we get</p>
<pre><code>Error, (in newton) The maximum number of steps 100 reached without convergence</code></pre>
<p>However, we can also add a complex number to the initial point.</p>
<pre><code>newton(x-&gt;x^2+4, 1.0*I)</code></pre>
<p>and get <code>2.0000I</code>.</p>
<h3 id="roots-of-unity">Roots of Unity</h3>
<p>An interesting function to study in complex numbers is <span class="math inline">\(f(z)=z^{n}-1\)</span> for positive integers <span class="math inline">\(n\)</span>. When <span class="math inline">\(n=2\)</span>, we get the function <span class="math inline">\(x^{2}-1\)</span> which isn’t that interesting, but not bad. Note that the roots of this are <span class="math inline">\(x=\pm 1\)</span>. Let’s look at the solution to <span class="math inline">\(f(z)=z^{3}-1\)</span>.</p>
<p>A good way to do this is to recall that we can write <span class="math inline">\(z\)</span> in its polar form or <span class="math display">\[z=re^{i\theta}\]</span> and then we want to solve <span class="math display">\[ z^{3}-1 = r^{3} e^{3i\theta}-1\]</span> Since we can write <span class="math inline">\(1=1e^{0 i}\)</span>, then <span class="math display">\[
r^{3} e^{3i\theta} = e^{0i}\]</span> results in <span class="math inline">\(r^{3}=1\)</span> or <span class="math inline">\(r=1\)</span> and <span class="math inline">\(\theta=0\)</span>. This is the number <span class="math inline">\(z_1=1\)</span> and we know that <span class="math inline">\(1^{3}-1=0\)</span>. What else?</p>
<p>We can also write <span class="math inline">\(1=e^{2\pi i}\)</span> so <span class="math display">\[3i \theta = 2\pi i\]</span> or <span class="math inline">\(\theta=2\pi/3\)</span>, so another root of <span class="math inline">\(f\)</span> is <span class="math display">\[z_2=e^{2\pi/3 i}\]</span></p>
<p>and lastly, we can also write <span class="math inline">\(1=e^{4\pi i}\)</span> so another root when <span class="math inline">\(\theta=4\pi/3\)</span> or the number <span class="math display">\[z_3= e^{4 \pi i/3}\]</span>.</p>
<p>If we plot these three points, we get:</p>
<figure>
<img src="images/ch15/plot04.png" alt="Plot of the roots of f(z)=z^{3}-1" /><figcaption aria-hidden="true">Plot of the roots of <span class="math inline">\(f(z)=z^{3}-1\)</span></figcaption>
</figure>
<p>These points are on the unit circle and equally spaced with <span class="math inline">\(z=1\)</span> a root. This is true in general for functions of the form <span class="math inline">\(f(z)=z^{n}-1\)</span>, which will have the roots on the unit circle equally spaced <span class="math inline">\(2\pi/n\)</span> radians apart from each other.</p>
<h3 id="return-to-newtons-method">Return to Newton’s method</h3>
<p>We’re going to apply Newton’s method to find roots of <span class="math inline">\(f(z)=z^{3}-1\)</span>.</p>
<h4 id="exercise">Exercise</h4>
<p>Apply Newton’s method on this function for the following initial points:</p>
<ul>
<li><span class="math inline">\(z=0.1\)</span></li>
<li><span class="math inline">\(z=-i\)</span></li>
<li><span class="math inline">\(z=i\)</span></li>
<li><span class="math inline">\(z=-1\)</span></li>
<li><span class="math inline">\(z=0.5 i + 0.5\)</span></li>
</ul>
<p>Each of these will go to one of the 3 roots. To get a nice representation of this, we are going to do this for many points in the complex plane and color code the results. For example, the first and fourth point can be red, the 2nd and 5th points blue and the 3rd point green.</p>
<p>We now want to do this for many points in the complex plane. First, let’s defined a matrix to store a number of points:</p>
<pre><code>Z := Matrix(9, 9,(i,j)-&gt; (-2+2*I)+.5*(j-1)+(-1)*.5*(i-1)*I)</code></pre>
<p>will produce the following matrix:</p>
<pre><code>-2.0-2. I,-1.5-2. I,-1.0-2. I,-0.5-2. I,0.-2. I,0.5-2. I,1.0-2. I,1.5-2. I,2.0-2. I
-2.0-1.5 I,-1.5-1.5 I,-1.0-1.5 I,-0.5-1.5 I,0.-1.5 I,0.5-1.5 I,1.0-1.5 I,1.5-1.5 I,2.0-1.5 I
-2.0-1.0 I,-1.5-1.0 I,-1.0-1.0 I,-0.5-1.0 I,0.-1.0 I,0.5-1.0 I,1.0-1.0 I,1.5-1.0 I,2.0-1.0 I
-2.0-0.5 I,-1.5-0.5 I,-1.0-0.5 I,-0.5-0.5 I,0.-0.5 I,0.5-0.5 I,1.0-0.5 I,1.5-0.5 I,2.0-0.5 I
-2.0+0. I,-1.5+0. I,-1.0+0. I,-0.5+0. I,0.+0. I,0.5+0. I,1.0+0. I,1.5+0. I,2.0+0. I
-2.0+0.5 I,-1.5+0.5 I,-1.0+0.5 I,-0.5+0.5 I,0.+0.5 I,0.5+0.5 I,1.0+0.5 I,1.5+0.5 I,2.0+0.5 I
-2.0+1.0 I,-1.5+1.0 I,-1.0+1.0 I,-0.5+1.0 I,0.+1.0 I,0.5+1.0 I,1.0+1.0 I,1.5+1.0 I,2.0+1.0 I
-2.0+1.5 I,-1.5+1.5 I,-1.0+1.5 I,-0.5+1.5 I,0.+1.5 I,0.5+1.5 I,1.0+1.5 I,1.5+1.5 I,2.0+1.5 I
-2.0+2.0 I,-1.5+2.0 I,-1.0+2.0 I,-0.5+2.0 I,0.+2.0 I,0.5+2.0 I,1.0+2.0 I,1.5+2.0 I,2.0+2.0 I</code></pre>
<p>which is a grid of points in the Complex plane. We next want to apply Newton’s method to every number in the Matrix. If we do that, the point in the center will return an error, so we:</p>
<pre><code>Z[5,5]:=0.0001+0.0001I</code></pre>
<p>which is close to 0, but not exactly. Then</p>
<pre><code>roots:=map(a-&gt;newton(z-&gt;z^3-1, a), Z)</code></pre>
<p>returns a Matrix of the root that every value in <code>Z</code> goes to. To color code each of the points, we will first return the angle of each root:</p>
<pre><code>angles:=map(argument,roots)</code></pre>
<p>and now returns the angle (between <span class="math inline">\(-\pi\)</span> and <span class="math inline">\(\pi\)</span>) of every root. Lastly, we can now plot this using the <code>listdensityplot</code> command in the <code>plots</code> package:</p>
<pre><code>with(plots):
listdensityplot(angles,range=-Pi..Pi,colorstyle=HUE)</code></pre>
<p>which returns in <img src="images/ch15/plot05.png" alt="Plot of the roots of f(z)=z^{3}-1 using Newton’s method" /></p>
<p>Let’s create a procedure that does this. First, the following will create the matrix of inital values:</p>
<pre><code>complexGrid := proc (xRange::range, yRange::range, nx::posint, ny::posint)::Matrix;
  local dx, dy;
  dx := (rhs(xRange)-lhs(xRange))/(nx-1);
  dy := (rhs(yRange)-lhs(yRange))/(ny-1); LinearAlgebra[Transpose](Matrix(nx, ny, (i, j)-&gt;  lhs(xRange)+dx*(i-1)+I*rhs(yRange)-I*dy*(j-1)));
end proc:</code></pre>
<p>and as before, we have a problem with the middle entry (where the 0 +0I is) and the following will help locate it:</p>
<pre><code>closest := proc (A::Matrix, value)
    rtable_scanblock(A, [rtable_dims(A)], (val, ind, res) -&gt; ifelse(abs(val-value) &lt; abs(res[2]-value), [ind, val], res) , [[1, 1], A[1, 1]])
end proc</code></pre>
<p>Finally, the following will build up everything needed for the plot:</p>
<pre><code>NewtonPlot := proc (xRange::range, yRange::range, nx::posint, ny::posint)
  local Z, zeros, roots, angles;
  Z := complexGrid(xRange, yRange, nx, ny);
  zeros := closest(Z, 0+0*I);
  Z[op(zeros[1])] := 0.1e-4*I+0.1e-4;
  roots := map(a-&gt;newton(z-&gt;z^3-1, a), Z);
  angles := map(argument, roots);
  plots[listdensityplot](angles, range = -Pi .. Pi, colorstyle = HUE, style = patchnogrid, axes = none, smooth = true):
end proc</code></pre>
<p>And if one enters:</p>
<pre><code>NewtonPlot(-2.0 .. 2.0, -2.0 .. 2.0, 250, 250)</code></pre>
<p>the result is</p>
<figure>
<img src="images/ch15/plot06.png" alt="An example of Newton’s Method in the Complex Plane" /><figcaption aria-hidden="true">An example of Newton’s Method in the Complex Plane</figcaption>
</figure>
<h2 id="mandlebrot-set">Mandlebrot Set</h2>
<p>This section explore a very interesting visual look at an iteration of complex numbers.</p>
<p>We consider the iteration</p>
<p><span class="math display">\[z_{n+1}=z_n^{2} + C \qquad z_0 = 0\]</span> for some complex number <span class="math inline">\(C\)</span>. Let’s examine a few examples.</p>
<p>If <span class="math inline">\(C=i\)</span>, then using Maple, if we type</p>
<pre><code>z:=n-&gt;z(n-1)^2+I
z(0):=0</code></pre>
<p>and <code>seq(z(n),n=0..5)</code> returns <span class="math inline">\(0, I, -1+I, -I, -1+I, -I\)</span> and notice that the last two term will continue under repetition.</p>
<p>If <span class="math inline">\(C=1+I\)</span>, then the first 6 terms is: <span class="math display">\[0, 1+I, 1+3I, -7+7I, 1-97I, -9407-193I\]</span> and then the terms get further from the the origin.</p>
<p>We say that the sequence when <span class="math inline">\(C=I\)</span> is bounded and when <span class="math inline">\(C=1+I\)</span>, the sequence is unbounded. The set <span class="math inline">\(M=\{C \; | \; \lim_{n \rightarrow \infty} z_n\;\; \mbox{is bounded}\}\)</span> is called the <em>Mandelbrot Set</em> and is the set of all values of <span class="math inline">\(C\)</span> such that the iteration of the iteration is bounded. For example <span class="math inline">\(I\)</span> is in <span class="math inline">\(M\)</span>, but <span class="math inline">\(1+I\)</span> is not.</p>
<p>There is a theorem (that we won’t prove) that states: If <span class="math inline">\(|z_n|&gt;2\)</span>, then <span class="math inline">\(|z\_{n+1}| \rightarrow \infty\)</span> if <span class="math inline">\(z\_{n+1} = z\_n^{2}+C\)</span> for any value of <span class="math inline">\(C\)</span>.</p>
<p>Basically, this means that if there is a complex number <span class="math inline">\(z_n\)</span> such that <span class="math inline">\(|z_n|&gt;2\)</span>, then the sequence will diverge and it is not in the mandelbrot set.</p>
<p>It’s helpful to have a procedure that determines the number of steps such that <span class="math inline">\(|z_n|&gt;2\)</span>.</p>
<pre><code>mandelSteps := proc (c::complex, { maxsteps::posint := 50 })::posint;
  local i,z := 0.+0.*I;
  for i to maxsteps do
    z := z^2+c;
    if 2 &lt; abs(z) then break end if
  end do;
  return i;
end proc:</code></pre>
<p>This function is the main way of understanding the mandelbrot set. Let’s test it:</p>
<pre><code>mandelSteps(0+0*I)</code></pre>
<p>return 51, which basically means the origin is in the mandelbrot set, however,</p>
<pre><code>mandelSetps(1+I)</code></pre>
<p>returns 3, which means it took 3 steps to leave <span class="math inline">\(|z|&gt;2\)</span> and it is not in the Mandelbrot set.</p>
<h2 id="visualizing-the-mandelbrot-set">Visualizing the Mandelbrot Set</h2>
<p>The Mandelbrot Set is the set of all points <span class="math inline">\(C\)</span> such that the iteration <span class="math display">\[ z_{n+1} = z_n^{2}+C\]</span> is bounded.</p>
<p>A nice way to visualize this is for a grid of points <span class="math inline">\(C\)</span>, determine the number of steps to leave the set. Then we will do a density plot like above.</p>
<pre><code>C:=complexGrid(-2.0..1.0,-1.5..1.5,300,300):</code></pre>
<p>Then we perform the function <code>mandelSteps</code> on everyone point of the matrix:</p>
<pre><code>numsteps := map(mandelSteps, C)</code></pre>
<p>Then plot it like we did above:</p>
<pre><code>listdensityplot(LinearAlgebra[Transpose](numsteps), range = 1 .. 50, colorstyle = HUE, axes = none, smooth = true, style = patchnogrid)</code></pre>
<p>The result is <img src="images/ch15/plot07.png" alt="Plot of the Mandelbrot Set" /></p>
<p>A 3D version of this is developed using the <code>matrixplot</code> command:</p>
<pre><code>matrixplot(numsteps)</code></pre>
<p>and the result is <img src="images/ch15/plot08.png" alt="A 3D version of the Mandelbrot Set" /></p>
<h3 id="putting-it-all-together.">Putting it all together.</h3>
<p>As above, we create a procedure to do the plot in one shot.</p>
<pre><code>mandelPlot := proc (xRange::range, yRange::range, nx::posint, ny::posint)
  local C := complexGrid(xRange, yRange, nx, ny);
  local numsteps := map(c-&gt;mandelSteps(c, 100), C);
  listdensityplot(ArrayTools[FlipDimension](LinearAlgebra[Transpose](numsteps), 2), range = 1 .. 100, colorstyle = HUE, axes = none, smooth = true, style = patchnogrid, scaling = constrained);
end proc</code></pre>
<p>One can change the gradient colors by adding the option</p>
<pre><code>colorscheme = [&quot;Orange&quot;, &quot;DarkRed&quot;, &quot;DarkGreen&quot;, &quot;Blue&quot;, &quot;Black&quot;]</code></pre>
<p>to the <code>listdensityplot</code> command.</p>
<h3 id="exercise-1">Exercise</h3>
<p>Try zooming in on the Mandelbrot set by changing the plotting range. There are interesting things around the edge of the set.</p>
</body>
</html>
