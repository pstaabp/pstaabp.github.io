<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 13: Recursive Iteration, Rootfinding and Newton’s Method</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 13: Recursive Iteration, Rootfinding and Newton’s Method</h1>
</header>
<p><a href="index.html">Return to all notes</a></p>
<p>Before continuing with this chapter, we look at a way to find the zeros (or roots) of a function. Although Maple (and most CASs) have this built-in, we examine the details here.</p>
<p>Consider the function <span class="math inline">\(f(x)=x^{2}-2\)</span>, which is plotted below:</p>
<figure>
<img src="images/ch05/plot01.png" alt="Plot of x^{2}-2" /><figcaption aria-hidden="true">Plot of <span class="math inline">\(x^{2}-2\)</span></figcaption>
</figure>
<p>It has two roots <span class="math inline">\(x=\sqrt{2}\)</span> and <span class="math inline">\(x=-\sqrt{2}\)</span>. We will use this example to find a numerical approximation of this.</p>
<p>If we evaluate the function at <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=2\)</span>, note that <span class="math inline">\(f(0)=-2\)</span> and <span class="math inline">\(f(2)=2\)</span>. The intermediate value theorem states that if a function <span class="math inline">\(f\)</span> is continuous on an interval <span class="math inline">\([a,b]\)</span>, then <span class="math inline">\(f\)</span> takes on all values (<span class="math inline">\(y\)</span>-values or heights) between <span class="math inline">\(f(a)\)</span> and <span class="math inline">\(f(b)\)</span>. Specifically if <span class="math inline">\(d\)</span> is between <span class="math inline">\(f(a)\)</span> and <span class="math inline">\(f(b)\)</span>, then there exists at least one value <span class="math inline">\(c\)</span> such that <span class="math inline">\(f( c )=d\)</span>. See <a href="http://www.mathsisfun.com/algebra/intermediate-value-theorem.html">this page</a> for more information.</p>
<p>For this example, <span class="math inline">\(f\)</span> is continuous, so <span class="math inline">\(f\)</span> takes on all values between <span class="math inline">\(f(0)=-2\)</span> and <span class="math inline">\(f(2)=2\)</span>, including 0. That is, there is a number <span class="math inline">\(c\)</span> such that <span class="math inline">\(f( c )=0\)</span>. The value of <span class="math inline">\(c\)</span> is the root we seek.</p>
<h2 id="bisection-method">Bisection Method</h2>
<p>The bisection method exploits the intermediate value theorem to make sure that we always have a interval that contains a root. First, we will walk through the bisection method for the example and then write it down in general.</p>
<p>Let <span class="math inline">\(\tilde{a}\)</span> be the midpoint between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> or <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=2\)</span> in our case. That is <span class="math display">\[\tilde{a} = \frac{a+b}{2} = \frac{0+2}{2}=1\]</span> There are three choices for <span class="math inline">\(\tilde{a}\)</span>. Either it is 0, then you have found the root or it is less than zero or greater than zero. Since <span class="math inline">\(f(1)=-1\)</span>, then it is less than zero. Because our left endpoint was less than zero, we replace it with zero. That is our interval goes from <span class="math inline">\([0,2]\)</span> to <span class="math inline">\([1,2]\)</span>.</p>
<p>And then we repeat. The midpoint of this interval is 1.5 and <span class="math inline">\(f(1.5)=1.5^{2}-2=0.25\)</span> and since this is positive, we replace the 2 with 1.5 and our new interval is <span class="math inline">\([1,1.5]\)</span>.</p>
<p>###Exercise</p>
<p>Find the next 3 intervals using this technique. Recall that you always need to have the function value of one side be less than and the other be greater than 0.</p>
<p>###Stop this crazy thing!!!</p>
<p>Since you are wise, you notice that you can continue this process forever and you just don't have that much time. For example, on the tenth iteration, you should have the interval</p>
<pre><code>[1.41406250,1.416015625]</code></pre>
<p>and as long as the condition that the function values of two endpoints are opposite signs, then there is a guarantee of a root inside this interval.</p>
<p>Again, we can go on forever, but a good place to stop (often called a halting condition) is when the length of the interval shrinks to a particular size. Let’s say that we stop when the length is <span class="math inline">\(10^{-4}\)</span> and then we should return our best guess at the root, which may be the midpoint of the final interval. If we stop when the interval is less than <span class="math inline">\(10^{-4}\)</span> and take this midpoint, the answer will be 1.414215088.</p>
<p>###Creating a Procedure to do this</p>
<p>This section will slowly build up a procedure that does this. The goal of this section is to learn how to take an algorithm (explained above) and make a procedure that does this.</p>
<ol type="1">
<li><p>Shell of a procedure. Let’s start with the declaration of the procedure. We want to take a function and an interval in and return an approximate root.</p>
<pre><code>bisect:=proc(f::procedure,interval::range)::numeric;

end proc:</code></pre>
<p>This will just do that. Note that a function type is called a <code>procedure</code> and an interval is called a <code>range</code>. The return type will be a number, so <code>numeric</code>. It’s a good idea to just run this at this point.</p></li>
<li><p>Define the midpoint and return it.</p>
<p>Next, let’s do something super simple and define the midpoint and then return it. To get the endpoints of an interval or range, use <code>lhs</code> and <code>rhs</code>, which stands for left hand side and right hand side respectively.</p>
<pre><code>bisect:=proc(f::procedure,interval::range)::numeric;
   local mid:=0.5*(lhs(interval)+rhs(interval)):
    return mid:
end proc:</code></pre>
<p>and then execute this block of code. Make sure there are no errors. Then you can test it using the example above by typing <code>bisect(x-&gt;x^2,0..2)</code> and you should get the answer 1.0.</p></li>
<li><p>Create a new interval</p>
<p>Now, let’s also create a variable called <code>inter</code> that is the new interval. Recall that you want to make sure that the endpoints of the new interval are opposite signs. The easiest way to check this is to determine if the product of the function values is negative.</p>
<pre><code>bisect:=proc(f::procedure,interval::range)::numeric;
   local mid:=0.5*(lhs(interval)+rhs(interval)):
   local inter:=interval:
   if f(lhs(inter))*f(mid) &lt; 0 then
       inter := lhs(inter) .. mid
   else
      inter := mid .. rhs(inter)
   end if:
   return inter:
end proc:</code></pre>
<p>If we test this with <code>bisect(x-&gt;x^2-2,0..2)</code> we get <code>1.0 .. 2</code></p>
<p>which means that the root is in the interval [1.0,2.0].</p></li>
<li><p>Put in a loop to run a few times.</p>
<p>Next, we will run this a few times using a <code>for</code> loop to test the procedure.</p>
<pre><code>bisect:=proc(f::procedure,interval::range)::numeric;
   local mid:=0.5*(lhs(interval)+rhs(interval)):
   local inter:=interval:
   local i:

   for i to 4 do
     if f(lhs(inter))*f(mid) &lt; 0 then
       inter := lhs(inter) .. mid
     else
       inter := mid .. rhs(inter)
     end if:
     mid := .5*(lhs(inter)+rhs(inter)):
     print(inter):
    end do;
  return mid
end proc:</code></pre>
<p>This will print out the interval to make sure it is working. You should see the interval printed 4 times and then the midpoint returned (and then printed): <code>1.0 .. 2  1.0 .. 1.50  1.250 .. 1.50  1.3750 .. 1.50  1.43750</code></p>
<p>so this appears that the root is 1.43750 and is guaranteed to be in the interval [1.375,1.5]</p></li>
<li><p>Replace the for loop with a while loop</p>
<p>We don’t want to run this a fixed number of times, but instead, run this until the halting condition.</p>
<p>We will execute the loop while the length of the interval is greater than <span class="math inline">\(10^{-4}\)</span>.</p>
<pre><code>bisect := proc (f::procedure, interval::range)::numeric;
  local mid := .5*(lhs(interval)+rhs(interval));
  local inter := interval;
  while rhs(inter)-lhs(inter) &gt; 10^(-4) do
    if f(lhs(inter))*f(mid) &lt; 0 then
      inter := lhs(inter) .. mid
    else
      inter := mid .. rhs(inter)
    end if;
    mid := .5*(lhs(inter)+rhs(inter));
    print(inter):
  end do;
  return mid:
end proc:</code></pre>
<p>If we test the procedure by typing: <code>bisect(x-&gt;x^2-2,0..2)</code>, you will get 1.414215088. Note that we can determine the number of digits of accuracy for <span class="math inline">\(\sqrt{2}\)</span> by typing <code>evalf(|sqrt(2)-1.414215088|)</code> will result in 0.000001526 or 5 digits of accuracy.</p></li>
<li><p>Adding a parameter for the halting condition.</p>
<p>If we want the halting condition to be smaller than <span class="math inline">\(10^{-4}\)</span>, we will make it a parameter. Here’s how that works.</p>
<pre><code>bisect := proc (f::procedure, interval::range,{eps:=10^(-4)})::numeric;
  local mid := .5*(lhs(interval)+rhs(interval));
  local inter := interval;
  while rhs(inter)-lhs(inter) &gt; eps do
    if f(lhs(inter))*f(mid) &lt; 0 then
      inter := lhs(inter) .. mid
    else
      inter := mid .. rhs(inter)
    end if;
    mid := .5*(lhs(inter)+rhs(inter));
  end do;
  return mid:
end proc:</code></pre>
<p>and we have removed the print statement because all seems to be working well. Now if we call this procedure as above, <code>bisect(x-&gt;x^2-2,0..2)</code> then we get the same result as above.</p>
<p>But this allows us to get more precision. Type <code>bisect(x-&gt;x^2-2,0..2,eps=10^(-7))</code></p>
<p>gives this time 8 digits of accuracy.</p></li>
<li><p>Adding some help and error checking to this</p>
<p>It’s often helpful to add a description to the function, so here’s the final result:</p>
<pre><code>bisect := proc (f::procedure, interval::range,{eps:=10^(-4)})::numeric;
  description &quot;This procedure performs the bisection method on the function f with given range.  The parameter eps will determine  the halting condition.&quot;
  local mid := .5*(lhs(interval)+rhs(interval));
  local inter := interval;
  if f(rhs(inter))*f(lhs(inter))&gt;0 then
     error &quot;A root is not guaranteed to be in this interval.&quot;:
  end if:
  while rhs(inter)-lhs(inter) &gt; eps do
    if f(lhs(inter))*f(mid) &lt; 0 then
      inter := lhs(inter) .. mid
    else
      inter := mid .. rhs(inter)
    end if;
    mid := .5*(lhs(inter)+rhs(inter));
  end do;
  return mid:
end proc:</code></pre>
<p>The description is helpful to remember what the function does. If you type: <code>Describe(bisect)</code> You will see <code># This procedure performs the bisection method on the function f with given  # range.  # The parameter eps will determine the halting condition.  # The procedure returns the root of the function f within the given interval  # such that the  # interval is no wider than eps.  bisect( f::procedure, interval::range,      { eps := .1e-3 } ) :: numeric</code></p>
<p>and give a brief description of the function.</p>
<p>Also, we now have error checking built it.</p></li>
</ol>
<p>We will use this procedure in a homework problem.</p>
<h2 id="rootfinding-and-the-bisection-method">Rootfinding and the Bisection method</h2>
<p>Recall that we encountered the Bisection method in <a href="ch05.html">Chapter 5</a>. This was another way to do rootfinding. If we reenter the bisection procedure:</p>
<pre><code>function result = bisect(f,a,b,options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-6 
  end
   c = 0.5*(a+b); % calculate the midpoint of [a,b]
  if(b-a &lt; options.eps)  % the interval is small enough
      result = 0.5*(a+b);
  elseif (f(c)*f(a)&lt;0)
    result = bisect(f,a,c,&#39;eps&#39;,options.eps);
  else
    result = bisect(f,c,b,&#39;eps&#39;,options.eps);
  end
end</code></pre>
<p>We can find roots, like <span class="math inline">\(\sqrt{2}\)</span> using this instead.</p>
<pre><code>bisect(@(x) x^2-2,0,2,1e-6)</code></pre>
<h3 id="exercise">Exercise</h3>
<p>Find the solution to <span class="math inline">\(\cos x = x\)</span> using the bisection method. Hint: use algebra to get all terms to one side and define that</p>
<h2 id="recursive-iterations">Recursive Iterations</h2>
<p>Earlier, we have seen a few cases of iteration, in particular recursive iteration. For example, the sequence: <span class="math display">\[a_{n} = \frac{1}{a_{n-1}+1}\]</span> with <span class="math inline">\(a_1=1\)</span> generates a sequence. In <a href="ch-10.html">Chapter 10</a> we found the first few terms and then found the limit of this. Recall that if we define:</p>
<pre><code>a=zeros(10,1,&#39;sym&#39;);

a(1) = sym(1);
for i=2:10
    a(i) = 1/(a(i-1)+1);
end
a</code></pre>
<p>generates the first 10 terms or <span class="math display">\[1,\frac{1}{2},\frac{2}{3},\frac{3}{5},\frac{5}{8},{\frac {8}{13}},{\frac {13}{21}},{\frac {21}{34}},{\frac {34}{55}},{\frac {55}{89}},{\frac {89}{144}}\]</span></p>
<p>and as we discovered above, this sequence converges to the golden mean (or golden ratio) <span class="math display">\[\frac{1+\sqrt{5}}{2}\]</span></p>
<h2 id="finding-sqrta">Finding <span class="math inline">\(\sqrt{a}\)</span></h2>
<p>Another useful iterative sequence is the following: <span class="math display">\[x_{n+1} = \frac{x_n^{2}+a}{2x_n}\qquad x_0=a\]</span></p>
<p>for a positive number <span class="math inline">\(a\)</span>. We will show that this converges to <span class="math inline">\(\sqrt{a}\)</span>. For example, if <span class="math inline">\(a=2\)</span>, then</p>
<pre><code>xval = zeros(10,1,&quot;sym&quot;)  % make a zero 
xval(1)=1
for i=2:10
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1))
end
xval</code></pre>
<p>The first few terms of this we get: <span class="math display">\[1,\frac{3}{2},\frac{17}{12},\frac{577}{408},\frac{665857}{470832},\frac{886731088897}{627013566048},\ldots\]</span></p>
<p>and then the fraction gets quite large because we declared a symbolic array, so everything is rational. If instead, we use numeric array, like:</p>
<pre><code>format long
xval = zeros(6,1);  % make a zero 
xval(1)=2;
for i=2:length(xval)
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1));
end
xval</code></pre>
<p>the result is</p>
<p><span class="math display">\[2.0,1.500000000,1.416666666,1.414215686,1.414213562,
\ldots\]</span></p>
<h4 id="exercise.">Exercise.</h4>
<p>Use the above to find <span class="math inline">\(\sqrt{5}\)</span>.</p>
<h2 id="newtons-method">Newton’s Method</h2>
<p>(First, before trying any of these, you’ll probably want to <code>unassign('x')</code> to get everything to work correctly.)</p>
<p>The above formula is a specific case of Newton’s method for finding roots. Here’s a geometric view of Newton’s method.</p>
<p>We intend to find the point <span class="math inline">\(x^{\star}\)</span> such that <span class="math inline">\(f(x)=0\)</span>. We don’t know how to find <span class="math inline">\(x^{\star}\)</span>, but have an approximate solution, call it <span class="math inline">\(x_0\)</span>. Draw the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x_0\)</span>. The following plot is an example with <span class="math inline">\(f(x)=x^{2}-2\)</span> and <span class="math inline">\(x_0=0.4\)</span>:</p>
<figure>
<img src="images/ch13/plot01.png" alt="Newton’s Method for f(x)=x^{2}-2" /><figcaption aria-hidden="true">Newton’s Method for <span class="math inline">\(f(x)=x^{2}-2\)</span></figcaption>
</figure>
<p>The point on the left is <span class="math inline">\(x_0=0.5\)</span> and the green line is the tangent line there. Instead of using the function, we use the tangent line, which is easy to solve. That value is <span class="math inline">\(x_1=2.25\)</span>. At this point (no pun intended), we find the tangent line at <span class="math inline">\(x_1\)</span> and find where it crosses the <span class="math inline">\(x\)</span>-axis.</p>
<p>This process continues indefinitely and (for this example), it converges to <span class="math inline">\(\sqrt{2}\)</span>.</p>
<h3 id="why-this-works">Why this works</h3>
<p>Recall that the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x=a\)</span> is <span class="math display">\[y=f&#39;(a)(x-a)+f(a)\]</span> and if we set <span class="math inline">\(y=0\)</span> in the tangent line because we are seeking the root (where the function is 0) <span class="math display">\[0=f&#39;(a)(x-a)+f(a)\]</span> and then we solve for <span class="math inline">\(x\)</span>. (Either by hand or let Maple do it). <span class="math display">\[x=a+\frac{f(a)}{f&#39;(a)}\]</span></p>
<p>Next, if we let <span class="math inline">\(a=x_0\)</span>, our initial point and <span class="math inline">\(x\)</span> be <span class="math inline">\(x_1\)</span>, the next point: <span class="math display">\[x_1=x_0+\frac{f(x_0)}{f&#39;(x_0)}\]</span></p>
<p>or in general: <span class="math display">\[x_{n+1}=x_n+\frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>and this last equation is called <em>Newton’s rootfinding method</em> (or just <em>Newton’s method</em>)</p>
<p>###Example</p>
<p>Use Newton’s method to find the solution to <span class="math inline">\(\cos x = x\)</span>.</p>
<p>If we let <span class="math inline">\(f(x)=x-\cos x\)</span> and perform Newton’s method. Since, <span class="math inline">\(f&#39;(x)=1+\sin x\)</span>, this means that <span class="math display">\[x_{n+1} = x_n - \frac{x_n-\cos x_n}{1+\sin x_n}\]</span> and let’s use <span class="math inline">\(x_0=0\)</span> as an initial guess.</p>
<p>If we enter:</p>
<pre><code>xval = zeros(6,1);  % make an array of zeros
xval(1)=0;
for i=2:length(xval)
  xval(i) = xval(i-1) -(xval(i-1)-cos(xval(i-1)))/(1+sin(xval(i-1)));
end
xval</code></pre>
<p>the results are <span class="math display">\[0., 1.000000000, 0.7503638679, 0.7391128909, 0.7390851334, 0.7390851332\]</span></p>
<p>As you can see from the sequence, the last two numbers are the same for the first 9 digits.</p>
<p>And looking at a plot of <span class="math inline">\(x\)</span> and <span class="math inline">\(\cos x\)</span>,</p>
<figure>
<img src="images/ch13/plot02.png" alt="Plot looking for the solution of x=\cos x" /><figcaption aria-hidden="true">Plot looking for the solution of <span class="math inline">\(x=\cos x\)</span></figcaption>
</figure>
<p>The solution looks like about 0.73.</p>
<h4 id="exercise-1">Exercise</h4>
<p>There are two <span class="math inline">\(x\)</span> values such that <span class="math inline">\(1-x^{2}=\sin x\)</span>. Find the solution that satisfies <span class="math inline">\(x\lt 0\)</span>. Plot the two function to see if your answer is reasonable.</p>
<h3 id="creating-a-newtons-method-function">Creating a Newton’s Method function</h3>
<p>The following function:</p>
<pre><code>function result = newton(f,df,x0,options)
  arguments
    f function_handle
    df function_handle
    x0 (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-6 
  end

  x1=x0;
  
  dx=1; % this will be a step, just initialized to 1 to get the while loop started
  while(abs(dx)&gt;options.eps)
    dx=f(x1)/df(x1);
    x1 = x1-dx;
  end
  result = x1;
end</code></pre>
<p>can be used to solve Newton’s method for a given function <span class="math inline">\(f\)</span>, its derivative <span class="math inline">\(df\)</span> and an initial point <span class="math inline">\(x0\)</span>.</p>
</body>
</html>
