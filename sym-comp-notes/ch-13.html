<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 13: Recursive Iteration, Rootfinding and Newton’s Method</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 13: Recursive Iteration, Rootfinding and Newton’s Method</h1>
</header>
<p><a href="index.html">Return to all notes</a></p>
<h2 id="rootfinding-and-the-bisection-method">Rootfinding and the Bisection method</h2>
<p>Recall that we encountered the Bisection method in <a href="ch05.html">Chapter 5</a>. This was another way to do rootfinding. If we reenter the bisection procedure:</p>
<pre><code>function result = bisect(f,a,b,options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-6 
  end
   c = 0.5*(a+b); % calculate the midpoint of [a,b]
  if(b-a &lt; options.eps)  % the interval is small enough
      result = 0.5*(a+b);
  elseif (f(c)*f(a)&lt;0)
    result = bisect(f,a,c,&#39;eps&#39;,options.eps);
  else
    result = bisect(f,c,b,&#39;eps&#39;,options.eps);
  end
end</code></pre>
<p>We can find roots, like <span class="math inline">\(\sqrt{2}\)</span> using this instead.</p>
<pre><code>bisect(@(x) x^2-2,0,2,1e-6)</code></pre>
<h3 id="exercise">Exercise</h3>
<p>Find the solution to <span class="math inline">\(\cos x = x\)</span> using the bisection method. Hint: use algebra to get all terms to one side and define that</p>
<h2 id="recursive-iterations">Recursive Iterations</h2>
<p>Earlier, we have seen a few cases of iteration, in particular recursive iteration. For example, the sequence: <span class="math display">\[a_{n} = \frac{1}{a_{n-1}+1}\]</span> with <span class="math inline">\(a_1=1\)</span> generates a sequence. In <a href="ch-10.html">Chapter 10</a> we found the first few terms and then found the limit of this. Recall that if we define:</p>
<pre><code>a=zeros(10,1,&#39;sym&#39;);

a(1) = sym(1);
for i=2:10
    a(i) = 1/(a(i-1)+1);
end
a</code></pre>
<p>generates the first 10 terms or <span class="math display">\[1,\frac{1}{2},\frac{2}{3},\frac{3}{5},\frac{5}{8},{\frac {8}{13}},{\frac {13}{21}},{\frac {21}{34}},{\frac {34}{55}},{\frac {55}{89}},{\frac {89}{144}}\]</span></p>
<p>and as we discovered above, this sequence converges to the golden mean (or golden ratio) <span class="math display">\[\frac{1+\sqrt{5}}{2}\]</span></p>
<h2 id="finding-sqrta">Finding <span class="math inline">\(\sqrt{a}\)</span></h2>
<p>Another useful iterative sequence is the following: <span class="math display">\[x_{n+1} = \frac{x_n^{2}+a}{2x_n}\qquad x_0=a\]</span></p>
<p>for a positive number <span class="math inline">\(a\)</span>. We will show that this converges to <span class="math inline">\(\sqrt{a}\)</span>. For example, if <span class="math inline">\(a=2\)</span>, then</p>
<pre><code>xval = zeros(10,1,&quot;sym&quot;)  % make a zero 
xval(1)=1
for i=2:10
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1))
end
xval</code></pre>
<p>The first few terms of this we get: <span class="math display">\[1,\frac{3}{2},\frac{17}{12},\frac{577}{408},\frac{665857}{470832},\frac{886731088897}{627013566048},\ldots\]</span></p>
<p>and then the fraction gets quite large because we declared a symbolic array, so everything is rational. If instead, we use numeric array, like:</p>
<pre><code>format long
xval = zeros(6,1);  % make a zero 
xval(1)=2;
for i=2:length(xval)
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1));
end
xval</code></pre>
<p>the result is</p>
<p><span class="math display">\[2.0,1.500000000,1.416666666,1.414215686,1.414213562,
\ldots\]</span></p>
<h4 id="exercise.">Exercise.</h4>
<p>Use the above to find <span class="math inline">\(\sqrt{5}\)</span>.</p>
<h2 id="newtons-method">Newton’s Method</h2>
<p>(First, before trying any of these, you’ll probably want to <code>unassign('x')</code> to get everything to work correctly.)</p>
<p>The above formula is a specific case of Newton’s method for finding roots. Here’s a geometric view of Newton’s method.</p>
<p>We intend to find the point <span class="math inline">\(x^{\star}\)</span> such that <span class="math inline">\(f(x)=0\)</span>. We don’t know how to find <span class="math inline">\(x^{\star}\)</span>, but have an approximate solution, call it <span class="math inline">\(x_0\)</span>. Draw the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x_0\)</span>. The following plot is an example with <span class="math inline">\(f(x)=x^{2}-2\)</span> and <span class="math inline">\(x_0=0.4\)</span>:</p>
<figure>
<img src="images/ch13/plot01.png" alt="Newton’s Method for f(x)=x^{2}-2" /><figcaption aria-hidden="true">Newton’s Method for <span class="math inline">\(f(x)=x^{2}-2\)</span></figcaption>
</figure>
<p>The point on the left is <span class="math inline">\(x_0=0.5\)</span> and the green line is the tangent line there. Instead of using the function, we use the tangent line, which is easy to solve. That value is <span class="math inline">\(x_1=2.25\)</span>. At this point (no pun intended), we find the tangent line at <span class="math inline">\(x_1\)</span> and find where it crosses the <span class="math inline">\(x\)</span>-axis.</p>
<p>This process continues indefinitely and (for this example), it converges to <span class="math inline">\(\sqrt{2}\)</span>.</p>
<h3 id="why-this-works">Why this works</h3>
<p>Recall that the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x=a\)</span> is <span class="math display">\[y=f&#39;(a)(x-a)+f(a)\]</span> and if we set <span class="math inline">\(y=0\)</span> in the tangent line because we are seeking the root (where the function is 0) <span class="math display">\[0=f&#39;(a)(x-a)+f(a)\]</span> and then we solve for <span class="math inline">\(x\)</span>. (Either by hand or let Maple do it). <span class="math display">\[x=a+\frac{f(a)}{f&#39;(a)}\]</span></p>
<p>Next, if we let <span class="math inline">\(a=x_0\)</span>, our initial point and <span class="math inline">\(x\)</span> be <span class="math inline">\(x_1\)</span>, the next point: <span class="math display">\[x_1=x_0+\frac{f(x_0)}{f&#39;(x_0)}\]</span></p>
<p>or in general: <span class="math display">\[x_{n+1}=x_n+\frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>and this last equation is called <em>Newton’s rootfinding method</em> (or just <em>Newton’s method</em>)</p>
<p>###Example</p>
<p>Use Newton’s method to find the solution to <span class="math inline">\(\cos x = x\)</span>.</p>
<p>If we let <span class="math inline">\(f(x)=x-\cos x\)</span> and perform Newton’s method. Since, <span class="math inline">\(f&#39;(x)=1+\sin x\)</span>, this means that <span class="math display">\[x_{n+1} = x_n - \frac{x_n-\cos x_n}{1+\sin x_n}\]</span> and let’s use <span class="math inline">\(x_0=0\)</span> as an initial guess.</p>
<p>If we enter:</p>
<pre><code>xval = zeros(6,1);  % make an array of zeros
xval(1)=0;
for i=2:length(xval)
  xval(i) = xval(i-1) -(xval(i-1)-cos(xval(i-1)))/(1+sin(xval(i-1)));
end
xval</code></pre>
<p>the results are <span class="math display">\[0., 1.000000000, 0.7503638679, 0.7391128909, 0.7390851334, 0.7390851332\]</span></p>
<p>As you can see from the sequence, the last two numbers are the same for the first 9 digits.</p>
<p>And looking at a plot of <span class="math inline">\(x\)</span> and <span class="math inline">\(\cos x\)</span>,</p>
<figure>
<img src="images/ch13/plot02.png" alt="Plot looking for the solution of x=\cos x" /><figcaption aria-hidden="true">Plot looking for the solution of <span class="math inline">\(x=\cos x\)</span></figcaption>
</figure>
<p>The solution looks like about 0.73.</p>
<h4 id="exercise-1">Exercise</h4>
<p>There are two <span class="math inline">\(x\)</span> values such that <span class="math inline">\(1-x^{2}=\sin x\)</span>. Find the solution that satisfies <span class="math inline">\(x\lt 0\)</span>. Plot the two function to see if your answer is reasonable.</p>
<h3 id="creating-a-newtons-method-function">Creating a Newton’s Method function</h3>
<p>The following function:</p>
<pre><code>function result = newton(f,df,x0,options)
  arguments
    f function_handle
    df function_handle
    x0 (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-6 
  end

  x1=x0;
  
  dx=1; % this will be a step, just initialized to 1 to get the while loop started
  while(abs(dx)&gt;options.eps)
    dx=f(x1)/df(x1);
    x1 = x1-dx;
  end
  result = x1;
end</code></pre>
<p>can be used to solve Newton’s method for a given function <span class="math inline">\(f\)</span>, its derivative <span class="math inline">\(df\)</span> and an initial point <span class="math inline">\(x0\)</span>.</p>
</body>
</html>
