<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 13: Recursive Iteration, Rootfinding, Bisection Method and Newton’s Method</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 13: Recursive Iteration, Rootfinding, Bisection Method and Newton’s Method</h1>
</header>
<p><a href="ch-12.html">Previous Chapter</a> | <a href="index.html">Return to all notes</a> | <a href="ch-14.html">Next chapter</a></p>
<p>Before continuing with this chapter, we look at a way to find the zeros (or roots) of a function. Although Matlab (and most CASs) have this built-in, we examine the details here.</p>
<p>Consider the function <span class="math inline">\(f(x)=x^{2}-2\)</span>, which is plotted below:</p>
<figure>
<img src="images/ch13/plot01.png" alt="Plot of x^{2}-2" /><figcaption aria-hidden="true">Plot of <span class="math inline">\(x^{2}-2\)</span></figcaption>
</figure>
<p>It has two roots <span class="math inline">\(x=\sqrt{2}\)</span> and <span class="math inline">\(x=-\sqrt{2}\)</span>. We will use this example to find a numerical approximation of this.</p>
<p>If we evaluate the function at <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=2\)</span>, note that <span class="math inline">\(f(0)=-2\)</span> and <span class="math inline">\(f(2)=2\)</span>. The fact that these values have opposite signs is important. Recall the intermediate Value Theorem:</p>
<p><em>Intermediate Value Theorem</em> If a function <span class="math inline">\(f\)</span> is continuous on an interval <span class="math inline">\([a,b]\)</span>, then <span class="math inline">\(f\)</span> takes on all values (<span class="math inline">\(y\)</span>-values or heights) between <span class="math inline">\(f(a)\)</span> and <span class="math inline">\(f(b)\)</span>. Specifically if <span class="math inline">\(d\)</span> is between <span class="math inline">\(f(a)\)</span> and <span class="math inline">\(f(b)\)</span>, then there exists at least one value <span class="math inline">\(c\)</span> such that <span class="math inline">\(f( c )=d\)</span>.</p>
<p>See <a href="http://www.mathsisfun.com/algebra/intermediate-value-theorem.html">this page</a> for more information.</p>
<p>In the example of <span class="math inline">\(f(x)=x^2-2\)</span> on <span class="math inline">\([0,2]\)</span>, <span class="math inline">\(f\)</span> is continuous, so <span class="math inline">\(f\)</span> takes on all values between <span class="math inline">\(f(0)=-2\)</span> and <span class="math inline">\(f(2)=2\)</span>, including 0. That is, there is a number <span class="math inline">\(c\)</span> such that <span class="math inline">\(f( c )=0\)</span>. The value of <span class="math inline">\(c\)</span> is the root we seek.</p>
<h2 id="bisection-method">Bisection Method</h2>
<p>The bisection method exploits the Intermediate Value Theorem to make sure that we always have a interval that contains a root. First, we will walk through the bisection method for the example and then write it down in general.</p>
<p>Let <span class="math inline">\(\tilde{a}\)</span> be the midpoint between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> or <span class="math inline">\(x=0\)</span> and <span class="math inline">\(x=2\)</span> in our case. That is <span class="math display">\[\tilde{a} = \frac{a+b}{2} = \frac{0+2}{2}=1\]</span> There are three choices for <span class="math inline">\(f(\tilde{a})\)</span>. Either it is 0, then you have found the root or it is less than zero or greater than zero.</p>
<p>In this example, <span class="math inline">\(f(1)=-1\)</span>, then it is less than zero. Because our left endpoint was less than zero, we replace the interval <span class="math inline">\([0,2]\)</span> with <span class="math inline">\([1,2]\)</span>. The new interval <span class="math inline">\([1,2]\)</span> satisfies the condition that the function values are opposite signs.</p>
<p>And then we repeat. The midpoint of this interval is 1.5 and <span class="math inline">\(f(1.5)=1.5^{2}-2=0.25\)</span> and since this is positive, we replace the 2 with 1.5 and our new interval is <span class="math inline">\([1,1.5]\)</span>.</p>
<h4 id="exercise">Exercise</h4>
<p>Find the next 3 intervals using this technique. Recall that you always need to have the function value of one side be less than and the other be greater than 0.</p>
<p>###Stop this crazy thing!!!</p>
<p>Since you are wise, you notice that you can continue this process forever and you just don’t have that much time. For example, on the tenth iteration, you should have the interval</p>
<pre><code>[1.41406250,1.416015625]</code></pre>
<p>and as long as the condition that the function values of two endpoints are opposite signs, then there is a guarantee of a root inside this interval.</p>
<p>Again, we can go on forever, but a good place to stop (often called a halting condition) is when the length of the interval shrinks to a particular size. Let’s say that we stop when the length is <span class="math inline">\(10^{-4}\)</span> and then we should return our best guess at the root, which may be the midpoint of the final interval. If we stop when the interval is less than <span class="math inline">\(10^{-4}\)</span> and take this midpoint, the answer will be 1.414215088.</p>
<h3 id="creating-a-function-to-do-this">Creating a Function to do this</h3>
<p>This section will slowly build up a procedure that does this. The goal of this section is to learn how to take an algorithm (explained above) and make a function that does this. Make a new Script (not a live script)</p>
<ol type="1">
<li><p>Let’s start with a template. We want to take a function and an interval (that is two numbers) in and return an approximate root.</p>
<pre><code>function result = bisect(f,a,b)

end</code></pre>
<p>This will just do that.</p>
<p>Save the script as <code>bisect.m</code> in the directory where you have added other scripts for this class. Earlier we put them in a directory called <code>ext_functions</code>. This isn’t required, but if the name is different, make sure you adapt. Then try to run the function:</p>
<pre><code>addpath(&quot;ext_functions/&quot;)
bisect(@(x) x^2-2,0,2)</code></pre>
<p>and if all goes well, there won’t be errors. If you get errors, double check that the function name is correct and the directory is correct.</p></li>
<li><p>Add in some checking on the arguments. Matlab has some nice ways to make sure that the inputs are correct. Here’s how to do that:</p>
<pre><code>function result = bisect(f,a,b,options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
  end
end</code></pre>
<p>where all of the arugments are listed in the <code>arguments</code> block and</p>
<ul>
<li><code>f</code> is checked to make sure it is a function handle</li>
<li><code>a</code> and <code>b</code> are numbers (or in Matlab-speak 1 by 1 matrices) the <code>mustBeReal</code> in the braces ensure you are not putting in things like complex numbers.</li>
</ul>
<p>Let’s check to make sure this is okay.<br />
If we result the function:</p>
<pre><code>bisect(@(x) x^2-2,0,2)</code></pre>
<p>you shouldn’t see any errors. However,</p>
<pre><code>syms x
bisect(x^2-2,0,2)</code></pre>
<p>returns an error that is like:</p>
<pre><code>Error using bisect
  Invalid argument at position 1. Value must be of type function_handle or be convertible to function_handle.</code></pre></li>
<li><p>Define the midpoint and return it.</p>
<p>Next, let’s do something super simple and define the midpoint and then return it. Add the lines:</p>
<pre><code>  c = 0.5*(a+b); % calculate the midpoint of [a,b]
  result = c;</code></pre>
<p>after the <code>end</code> that ends the arguments block of code (or between the two <code>end</code>s).</p>
<p>Try running this block of code. Make sure there are no errors.</p>
<pre><code>bisect(@(x) x^2-2,0,2)</code></pre>
<p>and you should get the answer 1. Note: if you don’t see any output, double-check that you included the <code>result=c</code> line. To get a function to return a value, you must assign output variable (on the top line of the function) to a value.</p></li>
<li><p><em>Create a new interval</em></p>
<p>Now, let’s assign the <code>result</code> variable to an interval instead. Recall that you want to make sure that the endpoints of the new interval are opposite signs. The easiest way to check this is to determine if the product of the function values is negative and we’ll make and <code>if</code> block like:</p>
<pre><code>function result = bisect(f,a,b) %options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
  end
  c = 0.5*(a+b); % calculate the midpoint of [a,b]
  if (f(c)*f(a)&lt;0)
    result = [a c]; %bisect(f,a,c,&#39;eps&#39;,options.eps);
  else
    result = [c b];%bisect(f,c,b,&#39;eps&#39;,options.eps);
  end
end</code></pre>
<p>If we test this with <code>bisect(@(x) x^2-2,0..2)</code> we get</p>
<pre><code>[1  2]</code></pre>
<p>which means that the root is in the interval [1,2].</p></li>
<li><p><em>Use recursion to do a number of steps</em> We will call the bisect function inside <code>if</code> block instead. Consider</p>
<pre><code>function result = bisect(f,a,b) %options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
  end
  c = 0.5*(a+b); % calculate the midpoint of [a,b]
  if (f(c)*f(a)&lt;0)
    result = bisect(f,a,c);
  else
    result = bisect(f,c,b); 
  end
end</code></pre>
<p>and notice that in the <code>if</code> block we call bisect again (this makes it resursive) on the interval either <span class="math inline">\([a,c]\)</span> or <span class="math inline">\([c,b]\)</span>. <strong>Don’t run this yet</strong></p>
<p>If you do, you’ll get an error (about a limit of the number of recursive calls, which isn’t the end of the work). This is because remember that with a recursive function you always need a way to stop the recursion. What we’ll do is if the interval is small enough, we’ll stop and return the root.</p>
<pre><code>function result = bisect(f,a,b) %options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
  end
  c = 0.5*(a+b); % calculate the midpoint of [a,b]
  if (b-a)&lt;0.0001
    result = c;
  elseif (f(c)*f(a)&lt;0)
    result = bisect(f,a,c);
  else
    result = bisect(f,c,b); 
  end
end</code></pre>
<p>Let’s give this one a go: <code>bisect(@(x) x^2-2,0..2)</code> and the answer is returned 1.4142</p></li>
<li><p><em>Allow more robust cutoff values</em></p>
<p>In the example above, the bisection method stops when the interval length reaches 0.0001, but what if we want it more precise. We can add an optional argument in the following way:</p>
<pre><code>function result = bisect(f,a,b, options)
  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-4 
  end
  c = 0.5*(a+b); % calculate the midpoint of [a,b]
  options.eps
  if b-a&lt; options.eps
      result = c;
  elseif (f(c)*f(a)&lt;0)
    result = bisect(f,a,c,&#39;eps&#39;,options.eps);
  else
    result = bisect(f,c,b,&#39;eps&#39;,options.eps);
  end
end</code></pre>
<p>and notice that it is important that we send the options to the function recursively in the <code>if</code> block.</p>
<p>If we run the function again, it will be exactly the same, but we will see below that we optionally throw in a way to get more accurate numbers.</p>
<p>First, if we change the output format to</p>
<pre><code>format long</code></pre>
<p>and rerun the same command above, we’ll get 1.414215087890625. How accurate is this?</p>
<p>In this case, we know the exact answer is <span class="math inline">\(\sqrt{2}\)</span>, so we can do</p>
<pre><code>x0 = bisect(f,0,2)
abs(x0-sqrt(2))</code></pre>
<p>which returns 1.525517529854525e-06, meaning that it is about 6 digits accurate.</p>
<p>If we run:</p>
<pre><code>x0 = bisect(@(x) x^2-2,0,2,&#39;eps&#39;,1e-10)
abs(x0-sqrt(2))</code></pre>
<p>we get 1.795119608516416e-11, which is nearly 11 digits of accuracy.</p></li>
</ol>
<h3 id="exercise-1">Exercise</h3>
<p>Find the solution to <span class="math inline">\(\cos x = x\)</span> using the bisection method. Hint: use algebra to get all terms to one side. You may need to plot the function to get an idea where the solution is.</p>
<h2 id="recursive-iterations">Recursive Iterations</h2>
<p>Earlier, we have seen a few cases of iteration, in particular recursive iteration. For example, the sequence: <span class="math display">\[a_{n} = \frac{1}{a_{n-1}+1}\]</span> with <span class="math inline">\(a_1=1\)</span> generates a sequence. In <a href="ch-10.html">Chapter 10</a> we found the first few terms and then found the limit of this. Recall that if we define:</p>
<pre><code>a=zeros(10,1,&#39;sym&#39;);

a(1) = sym(1);
for i=2:10
    a(i) = 1/(a(i-1)+1);
end
a</code></pre>
<p>generates the first 10 terms or <span class="math display">\[1,\frac{1}{2},\frac{2}{3},\frac{3}{5},\frac{5}{8},{\frac {8}{13}},{\frac {13}{21}},{\frac {21}{34}},{\frac {34}{55}},{\frac {55}{89}},{\frac {89}{144}}\]</span></p>
<p>and as we discovered above, this sequence converges to the golden mean (or golden ratio) <span class="math display">\[\frac{1+\sqrt{5}}{2}\]</span></p>
<h2 id="finding-sqrta">Finding <span class="math inline">\(\sqrt{a}\)</span></h2>
<p>Another useful iterative sequence is the following: <span class="math display">\[x_{n+1} = \frac{x_n^{2}+a}{2x_n}\qquad x_0=a\]</span></p>
<p>for a positive number <span class="math inline">\(a\)</span>. We will show that this converges to <span class="math inline">\(\sqrt{a}\)</span>. For example, if <span class="math inline">\(a=2\)</span>, then</p>
<pre><code>xval = zeros(10,1,&quot;sym&quot;)  % make a zero 
xval(1)=1
for i=2:10
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1))
end
xval</code></pre>
<p>The first few terms of this we get: <span class="math display">\[1,\frac{3}{2},\frac{17}{12},\frac{577}{408},\frac{665857}{470832},\frac{886731088897}{627013566048},\ldots\]</span></p>
<p>and then the fraction gets quite large because we declared a symbolic array, so everything is rational. If instead, we use numeric array, like:</p>
<pre><code>format long
xval = zeros(6,1);  % make a zero 
xval(1)=2;
for i=2:length(xval)
  xval(i) = (xval(i-1)^2+2)/(2*xval(i-1));
end
xval</code></pre>
<p>the result is</p>
<p><span class="math display">\[2.0,1.500000000,1.416666666,1.414215686,1.414213562,
\ldots\]</span></p>
<h4 id="exercise.">Exercise.</h4>
<p>Use the above to find <span class="math inline">\(\sqrt{5}\)</span>.</p>
<h2 id="newtons-method">Newton’s Method</h2>
<p>The above formula is a specific case of Newton’s method for finding roots. Here’s a geometric view of Newton’s method.</p>
<p>We intend to find the point <span class="math inline">\(x^{\star}\)</span> such that <span class="math inline">\(f(x)=0\)</span>. We don’t know how to find <span class="math inline">\(x^{\star}\)</span>, but have an approximate solution, call it <span class="math inline">\(x_0\)</span>. Draw the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x_0\)</span>. The following plot is an example with <span class="math inline">\(f(x)=x^{2}-2\)</span> and <span class="math inline">\(x_0=0.5\)</span>:</p>
<figure>
<img src="images/ch13/plot02.png" alt="Newton’s Method for f(x)=x^{2}-2" /><figcaption aria-hidden="true">Newton’s Method for <span class="math inline">\(f(x)=x^{2}-2\)</span></figcaption>
</figure>
<p>The point on the left is <span class="math inline">\(x_0=0.5\)</span> and the green line is the tangent line there. Instead of using the function, we use the tangent line, which is easy to solve. That value is <span class="math inline">\(x_1=2.25\)</span>. At this point (no pun intended), we find the tangent line at <span class="math inline">\(x_1\)</span> and find where it crosses the <span class="math inline">\(x\)</span>-axis.</p>
<p>The tangent here is <span class="math inline">\(y=\frac{9}{2} (x-2.25)+(2.25)^2\)</span> and then it is added to the above plot to get: <img src="images/ch13/plot03.png" alt="Newton’s Method for f(x)=x^{2}-2" /></p>
<p>Then the tangent above is solved for <span class="math inline">\(x\)</span> to get <span class="math inline">\(x_2 = \frac{113}{72}\)</span>. We’ll show one more step to include the tangent line at this point: <img src="images/ch13/plot04.png" alt="Newton’s Method for f(x)=x^{2}-2" /></p>
<p>and visually it looks like it is very close to the root. It’s not exact and we can keep iterating until we get as close as we’d like.</p>
<h3 id="why-this-works">Why this works</h3>
<p>Recall that the tangent line to the curve <span class="math inline">\(y=f(x)\)</span> at <span class="math inline">\(x=a\)</span> is <span class="math display">\[y=f&#39;(a)(x-a)+f(a)\]</span> and if we set <span class="math inline">\(y=0\)</span> in the tangent line because we are seeking the root (where the function is 0) <span class="math display">\[0=f&#39;(a)(x-a)+f(a)\]</span> and then we solve for <span class="math inline">\(x\)</span>. (Either by hand or let Matlab do it). <span class="math display">\[x=a+\frac{f(a)}{f&#39;(a)}\]</span></p>
<p>Next, if we let <span class="math inline">\(a=x_0\)</span>, our initial point and <span class="math inline">\(x\)</span> be <span class="math inline">\(x_1\)</span>, the next point: <span class="math display">\[x_1=x_0+\frac{f(x_0)}{f&#39;(x_0)}\]</span></p>
<p>or in general: <span class="math display">\[x_{n+1}=x_n+\frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>and this last equation is called <em>Newton’s rootfinding method</em> (or just <em>Newton’s method</em>)</p>
<p>###Example</p>
<p>Use Newton’s method to find the solution to <span class="math inline">\(\cos x = x\)</span>.</p>
<p>If we let <span class="math inline">\(f(x)=x-\cos x\)</span> and perform Newton’s method. Since, <span class="math inline">\(f&#39;(x)=1+\sin x\)</span>, this means that <span class="math display">\[x_{n+1} = x_n - \frac{x_n-\cos x_n}{1+\sin x_n}\]</span> and let’s use <span class="math inline">\(x_0=0\)</span> as an initial guess.</p>
<p>If we enter:</p>
<pre><code>xval = zeros(6,1);  % make an array of zeros
xval(1)=0;
for i=2:length(xval)
  xval(i) = xval(i-1) -(xval(i-1)-cos(xval(i-1)))/(1+sin(xval(i-1)));
end
xval</code></pre>
<p>the results are <span class="math display">\[0., 1.000000000, 0.7503638679, 0.7391128909, 0.7390851334, 0.7390851332\]</span></p>
<p>As you can see from the sequence, the last two numbers are the same for the first 9 digits.</p>
<p>And looking at a plot of <span class="math inline">\(x\)</span> and <span class="math inline">\(\cos x\)</span>,</p>
<figure>
<img src="images/ch13/plot05.png" alt="Plot looking for the solution of x=\cos x" /><figcaption aria-hidden="true">Plot looking for the solution of <span class="math inline">\(x=\cos x\)</span></figcaption>
</figure>
<p>The solution looks like about 0.73.</p>
<h4 id="exercise-2">Exercise</h4>
<p>There are two <span class="math inline">\(x\)</span> values such that <span class="math inline">\(1-x^{2}=\sin x\)</span>. Find the solution that satisfies <span class="math inline">\(x\lt 0\)</span>. Plot the two function to see if your answer is reasonable.</p>
<h3 id="creating-a-newtons-method-function">Creating a Newton’s Method function</h3>
<p>The following function:</p>
<pre><code>function result = newton(f,df,x0,options)
  arguments
    f function_handle
    df function_handle
    x0 (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-6 
  end

  x1=x0;
  
  dx=1; % this will be a step, just initialized to 1 to get the while loop started
  while(abs(dx)&gt;options.eps)
    dx=f(x1)/df(x1);
    x1 = x1-dx;
  end
  result = x1;
end</code></pre>
<p>can be used to solve Newton’s method for a given function <span class="math inline">\(f\)</span>, its derivative <span class="math inline">\(df\)</span> and an initial point <span class="math inline">\(x0\)</span>.</p>
<p>We can now use this function to find roots. Here’s the solution to <span class="math inline">\(x^2-2=0\)</span>:</p>
<pre><code>syms x
f(x) = x^2-2;
df(x) = diff(f(x),x)
root = newton(@(x) f(x),@(x) df(x),1)
double(root)</code></pre>
<h4 id="exercise-3">Exercise</h4>
<ol type="1">
<li>Use the newton function above to find the solution to <span class="math inline">\(\cos(x) = x\)</span>.</li>
<li>Use the newton function above to find both solutions to <span class="math inline">\(\sin(x) = 1-x^2\)</span>. Hint: you’ll have to use different initial conditions to find both roots.</li>
</ol>
<h2 id="a-few-more-steps-to-get-the-bisection-function-a-bit-better">A few more steps to get the Bisection Function a bit better</h2>
<p>Although it seems like the bisection function above was fantastic, there’s a few other things to make it more robust in that it can handle any situations.</p>
<ol type="1">
<li><p><em>Ensuring that the intial interval has a root</em></p>
<p>To use the bisection method, there needs to be a root. Recall above, we invoked the intermediate value theorem to do this. A condition was that the function values at <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> had different signs. The following will check this. Put this just after the <code>arguments</code> block of code.</p>
<pre><code>if f(a)*f(b)&gt;0
  error(&quot;A root is not guaranteed on the given interval.&quot;)
end</code></pre>
<p>An example where this won’t work is the function <span class="math inline">\(f(x)=x^2+2\)</span>. It has not real root because it is always positive.</p>
<p>Calling the function with <code>bisect(@(x) x^2+2,0,2)</code> results in the error above.</p></li>
<li><p><em>Adding some help</em></p>
<p>It’s often helpful to add a description to the function, so here’s the latest</p>
<pre><code>function result = bisect(f,a,b, options)
% BISECT  Finds the root of the function on the interval [a,b] using the
% bisection method.

% root = bisect(f,a,b) 
%
% Example: bisect(@(x) x^2-2,0,2) finds the root of x^2-2 on the interval
% [0,2] which returns an approximation to the square root of 2. 
%
% Optional Arguments:
%   eps: a positive real number.  This is the stopping condition.  Defaults
%   to 1e-4

  arguments
    f function_handle
    a (1,1) {mustBeReal}
    b (1,1) {mustBeReal}
    options.eps (1,1) {mustBePositive} = 1e-4 
  end
  c = 0.5*(a+b); % calculate the midpoint of [a,b]

  if b-a&lt; options.eps
      result = c;
  elseif (f(c)*f(a)&lt;0)
    result = bisect(f,a,c,&#39;eps&#39;,options.eps);
  else
    result = bisect(f,c,b,&#39;eps&#39;,options.eps);
  end
end</code></pre>
<p>Where all of the help is written in comments at the top of the funciton. If you type: <code>help bisect</code> you will see the help text shown.</p></li>
</ol>
<h2 id="using-the-built-in-matlab-methods">Using the built-in Matlab methods</h2>
<p>Finding roots of functions or solutions of equations can be done with <code>solve</code> or <code>vpasolve</code>. First, consider solving <span class="math inline">\(\cos(x) = x\)</span> that we saw above. If we use the <code>solve</code> command with</p>
<pre><code>solve(cos(x)==x)</code></pre>
<p>Then first Matlab returns a warning:</p>
<pre><code>Warning: Unable to solve symbolically. Returning a numeric solution using vpasolve.</code></pre>
<p>and then retuns:</p>
<pre><code>0.73908513321516064165531208767387</code></pre>
<p>which appears to give about 30 decimals places.</p>
<p>And recall that for example with polynomials, Matlab often gives an unhelpful result:</p>
<pre><code>solve(x^5-100*x+1)</code></pre>
<p>returns an array of <code>root(z^5-100z+1,z,1)</code> whereas</p>
<pre><code>vpasolve(x^5-100*x+1)</code></pre>
<p>returns <span class="math display">\[
\left(\begin{array}{c}
-3.1647727346753370902009096534805\\
0.01000000000100000000050000000035\\
3.1597727034248370797270268345331\\
-0.0024999843752499947633085905264823-3.1622826011677773505491959715959\,\mathrm{i}\\
-0.0024999843752499947633085905264823+3.1622826011677773505491959715959\,\mathrm{i}
\end{array}\right)
\]</span> where the last two are complex solution.</p>
<p><a href="ch-12.html">Previous Chapter</a> | <a href="index.html">Return to all notes</a> | <a href="ch-14.html">Next chapter</a></p>
</body>
</html>
